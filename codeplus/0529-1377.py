# sorting
# 이 문제는 버블소트의 반복시행이 언제 의미를 가지지 않는가를 나타낸다
# 버블소트는 앞에서부터 하나씩 큰 수를 swap연산으로 뒤로 밀며 나아가는 형식,
# 뒤쪽부터 숫자가 고정된다. 때문에 한번도 swap연산이 일어나지 않는다 -> 정렬이 완료되는 숫자의미
# 그때의 인덱스 값을 구하는 문제인데 이는 이동한 숫자의 갯수를 세는 것과 같다
# 때문에 빠른 정렬을 이용하여 이동한 숫자중 가장 큰 숫자를 구해 달라진 인덱스의 차이(양수값) + 1한값이 이 문제의 답이된다
# 1을 더한 이유는 이동하게된 숫자중 가장 마지막 숫자도 swap연산이 일어나지 않는데 이는 인덱스의 차이에서 나타나지 않는다
# 때문에 이동한 숫자중 가장 큰 숫자의 인덱스 차이에서 + 1해준값이 답이된다.
# ex) 10 1 5 2 3 에서 1,2,3이 앞으로 이동하게 된다. 문제에서 주어진 값도 3이 출력 되는데 이는
# 버블소트를 진행하며 3의 원래 인덱스가 5에서 3으로 변경되고 이때 반복이 멈추기때문이다.(3또한 swap X)
# 이때 3이 이동한 인덱스는 2이고, 여기에 3도 이동한게 포함되어있지 않으므로 +1을 해준다.
import sys
input = sys.stdin.readline

n = int(input())
a = [0]*n
for i in range(n):
    a[i] = [int(input()), i]
a.sort()
ans = 0
for j in range(n):
    if a[j][1] - j > ans:
        ans = a[j][1] - j

print(ans+1)

